{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prospects Management Page de service Mises \u00e0 jour Version Date Auteur Description du changement 1.0.0 01-04-2022 Marcel Lhote cr\u00e9ation Diffusion Version Date Nom R\u00f4le 1.0.0 03-04-2022 Marcel Lhote SLAM Plan de classement : SLAM4 ; Java ; Android ; Niveau de confidentialit\u00e9 : confidentiel Introduction L'application \u00e0 pour objectif d'ajouter des prospects. Lors de rencontres dans des salons ou autres vous serez amener \u00e0 enregistrer des contacts pour votre entreprise. Prospect Management int\u00e8gre les fonctionnalit\u00e9s d'ajout de prospect et de synchronisation avec le serveur distant. Architecture L'application int\u00e8gre sa propre base de donn\u00e9es SQLite pour enregistrer les prospects m\u00eames ors connexion. L'utilisateur peut Synchroniser avec le serveur lorsque ce dernier est accessible par le biais d'une requ\u00eate api. Cas d'utilisation Ce diagramme pr\u00e9sente les fonctionnalit\u00e9s disponibles sur l'application graph TB rencontre(rencontre un prospect) identifie(s'identifie) ajoutpr(ajoute un prospect) recherchepr(recherche un prospect) sync(syncroniser les donn\u00e9es) serveurBdd[(Serveur distant)] Commercial:::user --> rencontre classDef user fill:#0acf00; identifie -- <<include>> --> rencontre rencontre -- <<extend>> --> ajoutpr rencontre -- <<extend>> --> recherchepr rencontre -- <<extend>> --> sync serveurBdd <--> sync Lors d'une rencontre avec un prospect, le commercial doit se connecter pour acc\u00e9der \u00e0 son application. Ensuite, il pourra enregistrer la personne avec diff\u00e9rentes informations (nous les verrons dans les pages java un peu apr\u00e8s), sinon il a la possibilit\u00e9 d'en rechercher un dans un tableau et derni\u00e8rement il peut synchroniser les donn\u00e9es avec un serveur distant (on r\u00e9cup\u00e8re les prospects du serveur et on lui donne les prospects qu'on a ajout\u00e9). Dans le cas o\u00f9 le prospect existerait d\u00e9j\u00e0, le serveur ne le rajoutera pas (on v\u00e9rifie que son nom, pr\u00e9nom ainsi que son entreprise ne soit pas les m\u00eames qu'un autre prospect existant).","title":"Accueil"},{"location":"#prospects-management","text":"","title":"Prospects Management"},{"location":"#page-de-service","text":"Mises \u00e0 jour Version Date Auteur Description du changement 1.0.0 01-04-2022 Marcel Lhote cr\u00e9ation Diffusion Version Date Nom R\u00f4le 1.0.0 03-04-2022 Marcel Lhote SLAM Plan de classement : SLAM4 ; Java ; Android ; Niveau de confidentialit\u00e9 : confidentiel","title":"Page de service"},{"location":"#introduction","text":"L'application \u00e0 pour objectif d'ajouter des prospects. Lors de rencontres dans des salons ou autres vous serez amener \u00e0 enregistrer des contacts pour votre entreprise. Prospect Management int\u00e8gre les fonctionnalit\u00e9s d'ajout de prospect et de synchronisation avec le serveur distant.","title":"Introduction"},{"location":"#architecture","text":"L'application int\u00e8gre sa propre base de donn\u00e9es SQLite pour enregistrer les prospects m\u00eames ors connexion. L'utilisateur peut Synchroniser avec le serveur lorsque ce dernier est accessible par le biais d'une requ\u00eate api.","title":"Architecture"},{"location":"#cas-dutilisation","text":"Ce diagramme pr\u00e9sente les fonctionnalit\u00e9s disponibles sur l'application graph TB rencontre(rencontre un prospect) identifie(s'identifie) ajoutpr(ajoute un prospect) recherchepr(recherche un prospect) sync(syncroniser les donn\u00e9es) serveurBdd[(Serveur distant)] Commercial:::user --> rencontre classDef user fill:#0acf00; identifie -- <<include>> --> rencontre rencontre -- <<extend>> --> ajoutpr rencontre -- <<extend>> --> recherchepr rencontre -- <<extend>> --> sync serveurBdd <--> sync Lors d'une rencontre avec un prospect, le commercial doit se connecter pour acc\u00e9der \u00e0 son application. Ensuite, il pourra enregistrer la personne avec diff\u00e9rentes informations (nous les verrons dans les pages java un peu apr\u00e8s), sinon il a la possibilit\u00e9 d'en rechercher un dans un tableau et derni\u00e8rement il peut synchroniser les donn\u00e9es avec un serveur distant (on r\u00e9cup\u00e8re les prospects du serveur et on lui donne les prospects qu'on a ajout\u00e9). Dans le cas o\u00f9 le prospect existerait d\u00e9j\u00e0, le serveur ne le rajoutera pas (on v\u00e9rifie que son nom, pr\u00e9nom ainsi que son entreprise ne soit pas les m\u00eames qu'un autre prospect existant).","title":"Cas d'utilisation"},{"location":"API/","text":"Introduction Les API permettent \u00e0 des applications de communiquer entre elles et de s'\u00e9changer mutuellement des services ou des donn\u00e9es. Serveur web \u00e0 distance Le serveur web permet d'effectuer des requ\u00eate d'api (GET, POST...) depuis application mobile. Il permet de r\u00e9cup\u00e9rer les prospects et d'ins\u00e9rer les nouveaux en base de donn\u00e9es mySql. Trois pages permettent les requ\u00eates api : connexionBase.php , getAllProspects.php et insetProspects.php . Connexion au serveur Cette page permet de v\u00e9rifier l'acc\u00e8s \u00e0 la base de donn\u00e9es depuis le serveur web. <?php /** * connexion \u00e0 la base de donn\u00e9es prospectsmanagement * @return PDO|null */ function connexionBase () { try { $connexion = new PDO ( $hote , $utilisateur , $mot_passe ); $connexion -> exec ( \"set names utf8\" ); return $connexion ; } catch ( PDOException $e ) { echo 'Erreur : ' . $e -> getMessage () . '<br />' ; echo 'N\u00b0 : ' . $e -> getCode (); return null ; } } GET : R\u00e9cup\u00e9rer les Prospects Le type de contenu est d\u00e9fini pour le format json avec comme encodage UTF-8 . Le r\u00e9sultat des donn\u00e9es en bdd est encod\u00e9e et \u00e9cris dans la page web. <?php header ( 'Content-type: application/json; charset=utf-8' ); require_once ( 'fonctionsDAL.inc' ); $status = 200 ; $data = null ; $data = getAllProspects (); header ( \"HTTP/1.1 \" . $status ); $response [ 'status' ] = $status ; if ( $data ) { $response [ 'data' ] = $data ; } $json_response = json_encode ( $response ); echo $json_response ; ?> Le format des donn\u00e9es re\u00e7u est sous ce format : { \"status\" : 200 , \"data\" : [ { \"id\" : \"28\" , \"nom\" : \"Armand\" , \"prenom\" : \"Enzo\" , \"tel\" : \"6877687\" , \"mail\" : \"htrhtr\" , \"note\" : \"5\" , \"siret\" : \"53008580200037\" , \"raisonsocial\" : \"facebook\" }, { \"id\" : \"29\" , \"nom\" : \"Baptiste\" , \"prenom\" : \"Enzo\" , \"tel\" : \"357786678\" , \"mail\" : \"rgrr\" , \"note\" : \"6\" , \"siret\" : \"48170829500037\" , \"raisonsocial\" : \"apple\" }, { \"id\" : \"30\" , \"nom\" : \"Baptiste\" , \"prenom\" : \"michael\" , \"tel\" : \"55416\" , \"mail\" : \"egegr\" , \"note\" : \"5\" , \"siret\" : \"51353675500012\" , \"raisonsocial\" : \"amazon\" } ] } POST : envoyer les prospects Toujours au format json, les donn\u00e9es peuvent \u00eatre r\u00e9cup\u00e9r\u00e9es pour alimenter la bdd mySql; La s\u00e9lection se fait par rapport \u00e0 la pr\u00e9c\u00e9dente date de synchronisation <?php header ( 'Content-type: application/json; charset=utf-8' ); $date = ( isset ( $_GET [ 'date' ])) ? $_GET [ 'date' ] : null ; $dataPost = file_get_contents ( 'php://input' ); setProspects ( $dataPost , $date ); ?> La fonction setProspects parcourt les donn\u00e9es et v\u00e9rifie s'il le prospect est d\u00e9j\u00e0 pr\u00e9sent dans la bdd. <?php /** * Permet d'ins\u00e9rer des prospects en bdd * @param $json : un json contenant les prospects * @return void */ function setProspects ( $json , $date ) { $res = json_decode ( $json ); // insertion ou mise \u00e0 jour des donn\u00e9es dans la table prospect //$res = $obj->prospects; foreach ( $res as $prospect ) { $nb = nbProspect ( $prospect -> { 'nom' }, $prospect -> { 'prenom' }, $prospect -> { 'raisonsocial' }); if ( $nb == 0 ) { insertprospect ( $prospect -> { 'id' }, $prospect -> { 'nom' }, $prospect -> { 'prenom' }, $prospect -> { 'tel' }, $prospect -> { 'mail' }, $prospect -> { 'note' }, $prospect -> { 'siret' }, $prospect -> { 'raisonsocial' }, $date ); } } } ?> Le format des donn\u00e9es json doit respecter le format exemple si dessous : { \"id\" : \"default\" , \"nom\" : \"Armand\" , \"prenom\" : \"Enzo\" , \"mail\" : \"htrhtr\" , \"tel\" : \"6877687\" , \"note\" : 5 , \"siret\" : 53008580200037 , \"raisonsocial\" : \"facebook\" }, { \"id\" : \"default\" , \"nom\" : \"Baptiste\" , \"prenom\" : \"Enzo\" , \"mail\" : \"rgrr\" , \"tel\" : \"357786678\" , \"note\" : 6 , \"siret\" : 48170829500037 , \"raisonsocial\" : \"apple\" }, { \"id\" : \"default\" , \"nom\" : \"Baptiste\" , \"prenom\" : \"michael\" , \"mail\" : \"egegr\" , \"tel\" : \"55416\" , \"note\" : 5 , \"siret\" : 51353675500012 , \"raisonsocial\" : \"amazon\" } API Siren Pour rechercher le Siren d'une entreprise par rapport \u00e0 sa raison social nous devons passer par l'API du gouvernement disponible \u00e0 l'adresse suivante : https://entreprise.data.gouv.fr/api/sirene/v1/full_text/ M\u00e9thodes Nous avons ici 1 m\u00e9thode principalement utilis\u00e9e, la premi\u00e8re intitul\u00e9 getSirenWithName qui prend en param\u00e8tre une variable \"nom\", elle permet de se connecter \u00e0 l'API et de faire une rechercher par rapport \u00e0 la variable donn\u00e9e qui est la plupart du temps la valeur que l'on met dans la zone de texte Raison sociale pendant la cr\u00e9ation d'un prospect. /** * R\u00e9cup\u00e8re le siret d'une entreprise avec son nom * * @param nom String : la d\u00e9nomination de l'entreprise * @return long : le siret de l'entreprise */ public long getSirenWithName ( String nom ) { try { URL url = new URL ( this . url + nom ); HttpURLConnection urlConnection = ( HttpURLConnection ) url . openConnection (); urlConnection . setRequestMethod ( \"GET\" ); urlConnection . setRequestProperty ( \"Content-Type\" , \"application/json; charset=utf-8\" ); BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( urlConnection . getInputStream ())); String stringBuffer ; response = \"\" ; while (( stringBuffer = bufferedReader . readLine ()) != null ) { response = String . format ( \"%s%s\" , response , stringBuffer ); } bufferedReader . close (); result = ( urlConnection . getResponseCode () == 200 ) ? \"R\u00e9cup\u00e9ration siret r\u00e9ussi\" : \"Erreur API\" ; urlConnection . disconnect (); } catch ( NoRouteToHostException e ) { result = \"Aucune connexion au serveur\" ; } catch ( Exception e ) { result = \"Erreur API\" ; e . printStackTrace (); } return siretWithJson ( response ); }","title":"Introduction"},{"location":"API/#introduction","text":"Les API permettent \u00e0 des applications de communiquer entre elles et de s'\u00e9changer mutuellement des services ou des donn\u00e9es.","title":"Introduction"},{"location":"API/#serveur-web-a-distance","text":"Le serveur web permet d'effectuer des requ\u00eate d'api (GET, POST...) depuis application mobile. Il permet de r\u00e9cup\u00e9rer les prospects et d'ins\u00e9rer les nouveaux en base de donn\u00e9es mySql. Trois pages permettent les requ\u00eates api : connexionBase.php , getAllProspects.php et insetProspects.php .","title":"Serveur web \u00e0 distance"},{"location":"API/#connexion-au-serveur","text":"Cette page permet de v\u00e9rifier l'acc\u00e8s \u00e0 la base de donn\u00e9es depuis le serveur web. <?php /** * connexion \u00e0 la base de donn\u00e9es prospectsmanagement * @return PDO|null */ function connexionBase () { try { $connexion = new PDO ( $hote , $utilisateur , $mot_passe ); $connexion -> exec ( \"set names utf8\" ); return $connexion ; } catch ( PDOException $e ) { echo 'Erreur : ' . $e -> getMessage () . '<br />' ; echo 'N\u00b0 : ' . $e -> getCode (); return null ; } }","title":"Connexion au serveur"},{"location":"API/#get-recuperer-les-prospects","text":"Le type de contenu est d\u00e9fini pour le format json avec comme encodage UTF-8 . Le r\u00e9sultat des donn\u00e9es en bdd est encod\u00e9e et \u00e9cris dans la page web. <?php header ( 'Content-type: application/json; charset=utf-8' ); require_once ( 'fonctionsDAL.inc' ); $status = 200 ; $data = null ; $data = getAllProspects (); header ( \"HTTP/1.1 \" . $status ); $response [ 'status' ] = $status ; if ( $data ) { $response [ 'data' ] = $data ; } $json_response = json_encode ( $response ); echo $json_response ; ?> Le format des donn\u00e9es re\u00e7u est sous ce format : { \"status\" : 200 , \"data\" : [ { \"id\" : \"28\" , \"nom\" : \"Armand\" , \"prenom\" : \"Enzo\" , \"tel\" : \"6877687\" , \"mail\" : \"htrhtr\" , \"note\" : \"5\" , \"siret\" : \"53008580200037\" , \"raisonsocial\" : \"facebook\" }, { \"id\" : \"29\" , \"nom\" : \"Baptiste\" , \"prenom\" : \"Enzo\" , \"tel\" : \"357786678\" , \"mail\" : \"rgrr\" , \"note\" : \"6\" , \"siret\" : \"48170829500037\" , \"raisonsocial\" : \"apple\" }, { \"id\" : \"30\" , \"nom\" : \"Baptiste\" , \"prenom\" : \"michael\" , \"tel\" : \"55416\" , \"mail\" : \"egegr\" , \"note\" : \"5\" , \"siret\" : \"51353675500012\" , \"raisonsocial\" : \"amazon\" } ] }","title":"GET : R\u00e9cup\u00e9rer les Prospects"},{"location":"API/#post-envoyer-les-prospects","text":"Toujours au format json, les donn\u00e9es peuvent \u00eatre r\u00e9cup\u00e9r\u00e9es pour alimenter la bdd mySql; La s\u00e9lection se fait par rapport \u00e0 la pr\u00e9c\u00e9dente date de synchronisation <?php header ( 'Content-type: application/json; charset=utf-8' ); $date = ( isset ( $_GET [ 'date' ])) ? $_GET [ 'date' ] : null ; $dataPost = file_get_contents ( 'php://input' ); setProspects ( $dataPost , $date ); ?> La fonction setProspects parcourt les donn\u00e9es et v\u00e9rifie s'il le prospect est d\u00e9j\u00e0 pr\u00e9sent dans la bdd. <?php /** * Permet d'ins\u00e9rer des prospects en bdd * @param $json : un json contenant les prospects * @return void */ function setProspects ( $json , $date ) { $res = json_decode ( $json ); // insertion ou mise \u00e0 jour des donn\u00e9es dans la table prospect //$res = $obj->prospects; foreach ( $res as $prospect ) { $nb = nbProspect ( $prospect -> { 'nom' }, $prospect -> { 'prenom' }, $prospect -> { 'raisonsocial' }); if ( $nb == 0 ) { insertprospect ( $prospect -> { 'id' }, $prospect -> { 'nom' }, $prospect -> { 'prenom' }, $prospect -> { 'tel' }, $prospect -> { 'mail' }, $prospect -> { 'note' }, $prospect -> { 'siret' }, $prospect -> { 'raisonsocial' }, $date ); } } } ?> Le format des donn\u00e9es json doit respecter le format exemple si dessous : { \"id\" : \"default\" , \"nom\" : \"Armand\" , \"prenom\" : \"Enzo\" , \"mail\" : \"htrhtr\" , \"tel\" : \"6877687\" , \"note\" : 5 , \"siret\" : 53008580200037 , \"raisonsocial\" : \"facebook\" }, { \"id\" : \"default\" , \"nom\" : \"Baptiste\" , \"prenom\" : \"Enzo\" , \"mail\" : \"rgrr\" , \"tel\" : \"357786678\" , \"note\" : 6 , \"siret\" : 48170829500037 , \"raisonsocial\" : \"apple\" }, { \"id\" : \"default\" , \"nom\" : \"Baptiste\" , \"prenom\" : \"michael\" , \"mail\" : \"egegr\" , \"tel\" : \"55416\" , \"note\" : 5 , \"siret\" : 51353675500012 , \"raisonsocial\" : \"amazon\" }","title":"POST : envoyer les prospects"},{"location":"API/#api-siren","text":"Pour rechercher le Siren d'une entreprise par rapport \u00e0 sa raison social nous devons passer par l'API du gouvernement disponible \u00e0 l'adresse suivante : https://entreprise.data.gouv.fr/api/sirene/v1/full_text/","title":"API Siren"},{"location":"API/#methodes","text":"Nous avons ici 1 m\u00e9thode principalement utilis\u00e9e, la premi\u00e8re intitul\u00e9 getSirenWithName qui prend en param\u00e8tre une variable \"nom\", elle permet de se connecter \u00e0 l'API et de faire une rechercher par rapport \u00e0 la variable donn\u00e9e qui est la plupart du temps la valeur que l'on met dans la zone de texte Raison sociale pendant la cr\u00e9ation d'un prospect. /** * R\u00e9cup\u00e8re le siret d'une entreprise avec son nom * * @param nom String : la d\u00e9nomination de l'entreprise * @return long : le siret de l'entreprise */ public long getSirenWithName ( String nom ) { try { URL url = new URL ( this . url + nom ); HttpURLConnection urlConnection = ( HttpURLConnection ) url . openConnection (); urlConnection . setRequestMethod ( \"GET\" ); urlConnection . setRequestProperty ( \"Content-Type\" , \"application/json; charset=utf-8\" ); BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( urlConnection . getInputStream ())); String stringBuffer ; response = \"\" ; while (( stringBuffer = bufferedReader . readLine ()) != null ) { response = String . format ( \"%s%s\" , response , stringBuffer ); } bufferedReader . close (); result = ( urlConnection . getResponseCode () == 200 ) ? \"R\u00e9cup\u00e9ration siret r\u00e9ussi\" : \"Erreur API\" ; urlConnection . disconnect (); } catch ( NoRouteToHostException e ) { result = \"Aucune connexion au serveur\" ; } catch ( Exception e ) { result = \"Erreur API\" ; e . printStackTrace (); } return siretWithJson ( response ); }","title":"M\u00e9thodes"},{"location":"javaAndroid/","text":"Connexion du commercial Diagramme de s\u00e9quence Ce diagramme pr\u00e9sente la proc\u00e9dure d'enregistrement d'un prospect dans la base de donn\u00e9es SQLite sequenceDiagram actor Commercial Commercial ->>+ Activity Login: saisit de l'identifiant / mot de passe Activity Login ->>+ DAO: getEmployeeWithIdentifiant(lIdentifiant) DAO -)+ Employee: create new Employee(identifiant, motDePasse) Employee -->>- DAO: lEmployee DAO -->>- Activity Login: lEmploye Activity Login ->>+ Employee: checkPassword(motDePasse) Employee -->>- Activity Login: true Activity Login ->> Activity Login : new Intent Activity Login -->>- Commercial: startActivity(MenuActivity) D\u00e9taille des m\u00e9thodes Le layout de connexion inclut les champs de saisies de l'identifiant, mot de passe et le bouton <EditText android:id= \"@+id/Identifiant\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_marginTop= \"68dp\" android:layout_marginBottom= \"26dp\" android:hint= \"Identifiant\" android:singleLine= \"true\" android:textSize= \"22sp\" /> <EditText android:id= \"@+id/MotDePasse\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_marginBottom= \"46dp\" android:hint= \"Mot de passe\" android:inputType= \"textPassword\" android:textSize= \"22sp\" /> <Button android:id= \"@+id/btnLogin\" android:layout_width= \"128dp\" android:layout_height= \"wrap_content\" android:layout_marginBottom= \"26dp\" android:background= \"@drawable/button_style1\" android:text= \"Connexion\" android:textColor= \"#1495d7\" android:textStyle= \"bold\" /> L'activit\u00e9 r\u00e9cup\u00e8re les informations saisies et v\u00e9rifie l'identit\u00e9 de la personne avec sa pr\u00e9sence en base de donn\u00e9es et son mot de passe chiffr\u00e9. Si aucune erreur n'est detect\u00e9e on passe \u00e0 l'activit\u00e9 menu. if ( editIdentifiant . getText (). length () > 0 && editPassword . getText (). length () > 0 ) { Employee lEmploye = database . getEmployeeBdd (). getEmployeeWithIdentifiant ( editIdentifiant . getText (). toString ()); if ( lEmploye != null && lEmploye . checkPassword ( editPassword . getText (). toString ())) { Intent menu = new Intent ( LoginActivity . this , MenuActivity . class ); menu . putExtra ( \"employee\" , lEmploye ); startActivity ( menu ); } }","title":"Connexion du commercial"},{"location":"javaAndroid/#connexion-du-commercial","text":"","title":"Connexion du commercial"},{"location":"javaAndroid/#diagramme-de-sequence","text":"Ce diagramme pr\u00e9sente la proc\u00e9dure d'enregistrement d'un prospect dans la base de donn\u00e9es SQLite sequenceDiagram actor Commercial Commercial ->>+ Activity Login: saisit de l'identifiant / mot de passe Activity Login ->>+ DAO: getEmployeeWithIdentifiant(lIdentifiant) DAO -)+ Employee: create new Employee(identifiant, motDePasse) Employee -->>- DAO: lEmployee DAO -->>- Activity Login: lEmploye Activity Login ->>+ Employee: checkPassword(motDePasse) Employee -->>- Activity Login: true Activity Login ->> Activity Login : new Intent Activity Login -->>- Commercial: startActivity(MenuActivity)","title":"Diagramme de s\u00e9quence"},{"location":"javaAndroid/#detaille-des-methodes","text":"Le layout de connexion inclut les champs de saisies de l'identifiant, mot de passe et le bouton <EditText android:id= \"@+id/Identifiant\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_marginTop= \"68dp\" android:layout_marginBottom= \"26dp\" android:hint= \"Identifiant\" android:singleLine= \"true\" android:textSize= \"22sp\" /> <EditText android:id= \"@+id/MotDePasse\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_marginBottom= \"46dp\" android:hint= \"Mot de passe\" android:inputType= \"textPassword\" android:textSize= \"22sp\" /> <Button android:id= \"@+id/btnLogin\" android:layout_width= \"128dp\" android:layout_height= \"wrap_content\" android:layout_marginBottom= \"26dp\" android:background= \"@drawable/button_style1\" android:text= \"Connexion\" android:textColor= \"#1495d7\" android:textStyle= \"bold\" /> L'activit\u00e9 r\u00e9cup\u00e8re les informations saisies et v\u00e9rifie l'identit\u00e9 de la personne avec sa pr\u00e9sence en base de donn\u00e9es et son mot de passe chiffr\u00e9. Si aucune erreur n'est detect\u00e9e on passe \u00e0 l'activit\u00e9 menu. if ( editIdentifiant . getText (). length () > 0 && editPassword . getText (). length () > 0 ) { Employee lEmploye = database . getEmployeeBdd (). getEmployeeWithIdentifiant ( editIdentifiant . getText (). toString ()); if ( lEmploye != null && lEmploye . checkPassword ( editPassword . getText (). toString ())) { Intent menu = new Intent ( LoginActivity . this , MenuActivity . class ); menu . putExtra ( \"employee\" , lEmploye ); startActivity ( menu ); } }","title":"D\u00e9taille des m\u00e9thodes"},{"location":"javaAndroid/DaoSQL/","text":"DAO SQL Introduction Cette classe h\u00e9rite de SQLiteOpenHelper . Elle fournit la cr\u00e9ation des tables et l'acc\u00e8s aux diff\u00e9rentes classes pour utiliser la base de donn\u00e9es. La classe ProspectBDD permet de communiquer avec les prospects et EmployeeBDD avec les employee dans le fichier db. Ces deux classes h\u00e9ritent de ObjectBDD. ObjectBDD Cette classe fournit les m\u00e9thodes open() et close pour acc\u00e9der en \u00e9criture \u00e0 la base de donn\u00e9es et refermer sa connexion /** * Cette classe fournit les attributs et m\u00e9thodes * pour toutes les tables de la bdd */ public abstract class ObjectBDD { private String name ; private String createSql ; private DaoSQL maBaseSQLite ; private SQLiteDatabase bdd ; EmployeeBDD Cette classe permet de g\u00e9rer les employ\u00e9es dans le fichier de base de donn\u00e9es. Cette m\u00e9thode utilise une requ\u00eate imbriqu\u00e9e pour \u00e9vier les injections sql au niveau du where identifiant = monIdentifiant . L'objet curseur permet de transformer le r\u00e9sultat d'une requ\u00eate sql en variable utilisable tel que String, int, boolean... /** * R\u00e9cup\u00e8re l'employee avec son nom * * @param identifiant String : le nom de l'employe * @return Employee ou null */ public Employee getEmployeeWithIdentifiant ( String identifiant ) { open (); String [] params = new String [ ( identifiant != null ? 1 : 0 ) ] ; int paramIndex = 0 ; String where = \"\" ; if ( identifiant != null ) { where = IDENTIFIANT_COL + \" = ?\" ; params [ paramIndex ++] = identifiant ; } Cursor c = getBdd (). query ( getTableName (), new String [] { IDENTIFIANT_COL , PASSWORD_COL }, where , params , null , null , null ); if ( c == null || c . getCount () == 0 ) { return null ; } c . moveToFirst (); Employee lEmploye = cursorToEmployee ( c ); c . close (); close (); return lEmploye ; } ProspectBDD Pour g\u00e9rer les prospects cette classe fournit une m\u00e9thode pour r\u00e9cup\u00e9rer une liste de prospect avec diff\u00e9rents crit\u00e8res non obligatoires. /** * R\u00e9cup\u00e8re un tableau de prospects * * @param nom String ou null : le nom du prospect * @param prenom String ou null : le prenom du prospect * @param raisonSocial String ou null : la raison social de l'entreprise * @return ArrayLsit<Prospect> ou null : la liste des prorpects correspondant aux crit\u00e8re ou null s'il n'existe aucun prospect correspondant */ public ArrayList < Prospect > getProspect ( String nom , String prenom , String raisonSocial ) {...} Pour l'ajout d'un prospect il est n\u00e9cessaire d'utiliser la classe ContentValues pour ins\u00e9rer des donn\u00e9es. Par d\u00e9faut le r\u00e9sultat renvoy\u00e9 est l'identifiant de la nouvelle insertion. /** * Ajoute un prospect \u00e0 la bdd * * @param p Prospect : le prospect \u00e0 ajouter * @return long : l'id du prospect */ public long addProspectBdd ( Prospect p ) { open (); //Cr\u00e9ation d'un ContentValues (fonctionne comme une HashMap) ContentValues values = new ContentValues (); //on lui ajoute une valeur associ\u00e9e \u00e0 une cl\u00e9 (qui est le nom de la colonne dans laquelle on veut mettre la valeur) values . put ( NOM_COL , p . getNom ()); values . put ( PRENOM_COL , p . getPrenom ()); values . put ( TEL_COL , p . getTel ()); values . put ( MAIL_COL , p . getMail ()); values . put ( NOTES_COL , p . getNotes ()); values . put ( SIRET_COL , p . getSiret ()); values . put ( RAISON_SOCIAL_COL , p . getRaisonSocial ()); //on ins\u00e8re l'objet dans la BDD via le ContentValues return getBdd (). insert ( getTableName (), null , values ); }","title":"DAO SQL"},{"location":"javaAndroid/DaoSQL/#dao-sql","text":"","title":"DAO SQL"},{"location":"javaAndroid/DaoSQL/#introduction","text":"Cette classe h\u00e9rite de SQLiteOpenHelper . Elle fournit la cr\u00e9ation des tables et l'acc\u00e8s aux diff\u00e9rentes classes pour utiliser la base de donn\u00e9es. La classe ProspectBDD permet de communiquer avec les prospects et EmployeeBDD avec les employee dans le fichier db. Ces deux classes h\u00e9ritent de ObjectBDD.","title":"Introduction"},{"location":"javaAndroid/DaoSQL/#objectbdd","text":"Cette classe fournit les m\u00e9thodes open() et close pour acc\u00e9der en \u00e9criture \u00e0 la base de donn\u00e9es et refermer sa connexion /** * Cette classe fournit les attributs et m\u00e9thodes * pour toutes les tables de la bdd */ public abstract class ObjectBDD { private String name ; private String createSql ; private DaoSQL maBaseSQLite ; private SQLiteDatabase bdd ;","title":"ObjectBDD"},{"location":"javaAndroid/DaoSQL/#employeebdd","text":"Cette classe permet de g\u00e9rer les employ\u00e9es dans le fichier de base de donn\u00e9es. Cette m\u00e9thode utilise une requ\u00eate imbriqu\u00e9e pour \u00e9vier les injections sql au niveau du where identifiant = monIdentifiant . L'objet curseur permet de transformer le r\u00e9sultat d'une requ\u00eate sql en variable utilisable tel que String, int, boolean... /** * R\u00e9cup\u00e8re l'employee avec son nom * * @param identifiant String : le nom de l'employe * @return Employee ou null */ public Employee getEmployeeWithIdentifiant ( String identifiant ) { open (); String [] params = new String [ ( identifiant != null ? 1 : 0 ) ] ; int paramIndex = 0 ; String where = \"\" ; if ( identifiant != null ) { where = IDENTIFIANT_COL + \" = ?\" ; params [ paramIndex ++] = identifiant ; } Cursor c = getBdd (). query ( getTableName (), new String [] { IDENTIFIANT_COL , PASSWORD_COL }, where , params , null , null , null ); if ( c == null || c . getCount () == 0 ) { return null ; } c . moveToFirst (); Employee lEmploye = cursorToEmployee ( c ); c . close (); close (); return lEmploye ; }","title":"EmployeeBDD"},{"location":"javaAndroid/DaoSQL/#prospectbdd","text":"Pour g\u00e9rer les prospects cette classe fournit une m\u00e9thode pour r\u00e9cup\u00e9rer une liste de prospect avec diff\u00e9rents crit\u00e8res non obligatoires. /** * R\u00e9cup\u00e8re un tableau de prospects * * @param nom String ou null : le nom du prospect * @param prenom String ou null : le prenom du prospect * @param raisonSocial String ou null : la raison social de l'entreprise * @return ArrayLsit<Prospect> ou null : la liste des prorpects correspondant aux crit\u00e8re ou null s'il n'existe aucun prospect correspondant */ public ArrayList < Prospect > getProspect ( String nom , String prenom , String raisonSocial ) {...} Pour l'ajout d'un prospect il est n\u00e9cessaire d'utiliser la classe ContentValues pour ins\u00e9rer des donn\u00e9es. Par d\u00e9faut le r\u00e9sultat renvoy\u00e9 est l'identifiant de la nouvelle insertion. /** * Ajoute un prospect \u00e0 la bdd * * @param p Prospect : le prospect \u00e0 ajouter * @return long : l'id du prospect */ public long addProspectBdd ( Prospect p ) { open (); //Cr\u00e9ation d'un ContentValues (fonctionne comme une HashMap) ContentValues values = new ContentValues (); //on lui ajoute une valeur associ\u00e9e \u00e0 une cl\u00e9 (qui est le nom de la colonne dans laquelle on veut mettre la valeur) values . put ( NOM_COL , p . getNom ()); values . put ( PRENOM_COL , p . getPrenom ()); values . put ( TEL_COL , p . getTel ()); values . put ( MAIL_COL , p . getMail ()); values . put ( NOTES_COL , p . getNotes ()); values . put ( SIRET_COL , p . getSiret ()); values . put ( RAISON_SOCIAL_COL , p . getRaisonSocial ()); //on ins\u00e8re l'objet dans la BDD via le ContentValues return getBdd (). insert ( getTableName (), null , values ); }","title":"ProspectBDD"},{"location":"javaAndroid/ajoutProspect/","text":"Ajouter un Prospect Introduction La classe AjoutProspectActivity h\u00e9rite de AppCompatActivity . Sont but est de permettre la cr\u00e9ation d'un nouveau prospect. Elle utilise la page layout activity_addprospect en tant que FrontEnd. M\u00e9thodes \u00c9v\u00e9nements Boutons Pour ce qui est des \u00e9v\u00e9nenements en rapport avec les boutons nous en avons 3. Le Premier intitul\u00e9 eventBtnRechercherEntreprise est li\u00e9 au bouton Rechercher. public View . OnClickListener eventBtnRechercherEntreprise = new View . OnClickListener () { @Override public void onClick ( View v ) { ApiGouv apiGouv = new ApiGouv (); long siren = apiGouv . getSirenWithName ( raisonSociale . getText (). toString ()); String sirenString = Long . toString ( siren ); siretText . setText ( sirenString , TextView . BufferType . EDITABLE ); boiteMessage ( apiGouv . getResult ()); } }; Il permet quand on clique dessus de rechercher gr\u00e2ce \u00e0 l'API du gouvernement sur les entreprises, le num\u00e9ro Siren de la raison sociale qu'on a \u00e9crit dans le EditText au dessus du bouton. Pour ce qui est du deuxi\u00e8me, il est intitul\u00e9 eventBtnEnregistrer et est li\u00e9 au bouton Enregistrer. La m\u00e9thode fais 115 lignes. (en contant les sauts de lignes et les commentaires) public View . OnClickListener eventBtnEnregistrer = new View . OnClickListener () { @Override public void onClick ( View v ) { /* R\u00e9cup\u00e9ration de ce qu'a \u00e9crit l'utilisateur dans les EditText puis on les transforment en chaine de caract\u00e8re qu'on stockent dans de nouvelles variables */ EditText raisonSocialeProspectTxt = ( EditText ) findViewById ( R . id . RaisonSociale ); String raisonSocialeProspect = raisonSocialeProspectTxt . getText (). toString (); EditText sirenProspectTxt = ( EditText ) findViewById ( R . id . Siren ); String sirenProspect = sirenProspectTxt . getText (). toString (); EditText nomProspectTxt = ( EditText ) findViewById ( R . id . Nom ); String nomProspect = nomProspectTxt . getText (). toString (); EditText prenomProspectTxt = ( EditText ) findViewById ( R . id . Prenom ); String prenomProspect = prenomProspectTxt . getText (). toString (); EditText mailProspectTxt = ( EditText ) findViewById ( R . id . Email ); String mailProspect = mailProspectTxt . getText (). toString (); EditText telProspectTxt = ( EditText ) findViewById ( R . id . Telephone ); String telProspect = telProspectTxt . getText (). toString (); EditText noteProspectTxt = ( EditText ) findViewById ( R . id . Notes ); String noteProspect = noteProspectTxt . getText (). toString (); /* Initialisation des Regex pour faire des tests par rapport aux entr\u00e9es de l'utilisateur */ String regexRaisonSociale = \"[A-Za-z0-9\\\\\u00e9\\\\\u00e8\\\\\u00ea\\\\\u00ef\\\\@\\\\/\\\\*\\\\-]+$\" ; String regexSiren = \"[0-9]{9}|0\" ; String regexNomPrenom = \"[A-Za-z\\\\\u00e9\\\\\u00e8\\\\\u00ea\\\\\u00ef\\\\-]+$\" ; String regexEmail = \"[a-zA-Z0-9._-]+@[a-z]+\\\\.+[a-z]+\" ; String regexPhoneNumber = \"(33|0033|0)[1-9][0-9]{8}$\" ; String regexNote = \"[0-9]|1[0-9]|20\" ; String regexSpace = \"(\\\\s+)$\" ; long sirenProspectTest = 0 ; String telProspectTest = \"\" ; int noteProspectTest = 0 ; String errorMessage = \"\" ; /* Cr\u00e9ation des tests sur les entr\u00e9es de l'utilisateur */ if ( nomProspectTxt . length () != 0 && prenomProspectTxt . length () != 0 && sirenProspectTxt . length () != 0 && raisonSocialeProspectTxt . length () != 0 && mailProspectTxt . length () != 0 ) { Prospect newProspect = new Prospect (); if ( raisonSocialeProspect . matches ( regexRaisonSociale ) && ! raisonSocialeProspect . matches ( regexSpace )) { newProspect . setRaisonSocial ( raisonSocialeProspect ); } else { errorMessage += \"- Raison Sociale \\n\" ; } if ( sirenProspect . matches ( regexSiren ) && ! sirenProspect . matches ( regexSpace )) { sirenProspectTest = Long . parseLong ( sirenProspect ); newProspect . setSiret ( sirenProspectTest ); } else { errorMessage += \"- Siren \\n\" ; } if ( prenomProspect . matches ( regexNomPrenom ) && ! prenomProspect . matches ( regexSpace )) { newProspect . setPrenom ( prenomProspect ); } else { errorMessage += \"- Pr\u00e9nom \\n\" ; } if ( nomProspect . matches ( regexNomPrenom ) && ! nomProspect . matches ( regexSpace )) { newProspect . setNom ( nomProspect ); } else { errorMessage += \"- Nom \\n\" ; } if ( mailProspect . matches ( regexEmail ) && ! mailProspect . matches ( regexSpace )) { newProspect . setMail ( mailProspect ); } else { errorMessage += \"- Mail \\n\" ; } if ( telProspect . length () == 0 || telProspect . matches ( regexPhoneNumber )) { telProspectTest = ( telProspect . length () == 0 ) ? \"0\" : telProspect ; newProspect . setTel ( telProspectTest ); } else { errorMessage += \"- T\u00e9l\u00e9phone \\n\" ; } if ( noteProspect . length () == 0 || ( noteProspect . matches ( regexNote ))) { noteProspectTest = ( noteProspect . length () == 0 ) ? 0 : Integer . parseInt ( noteProspect ); newProspect . setNotes ( noteProspectTest ); } else { errorMessage += \"- Note \\n\" ; } newProspect . setIsUpdate ( false ); if ( errorMessage . length () == 0 ){ dataBase . getProspectBdd (). add ( newProspect ); Intent retourMenu = new Intent ( AjoutProspectActivity . this , MenuActivity . class ); retourMenu . putExtra ( \"employee\" , lEmployee ); startActivity ( retourMenu ); } else { boiteMessage ( \"Sont invalides :\\n\" + errorMessage ); } } else { boiteMessage ( \"L'un des champs suivants est vide.\\n\" + \"\\n\" + \"Sont obligatoires : \\n\" + \"La Raison Sociale de l'entreprise\\n\" + \"Le Siret\\n\" + \"Le Nom\\n\" + \"Le Pr\u00e9nom\\n\" + \"Le Mail\" ); } } }; Il y a 3 parties coup\u00e9es par des commentaires. La premi\u00e8re qui permet d'obtenir sous la forme d'une chaine de caract\u00e8re ce que l'utilisateur a \u00e9crit dans chacun des EditText. La seconde qui met en place les Regex pour les prochains tests. Et finalement les tests sur ce que l'usager \u00e0 mis compar\u00e9s aux Regex. Pour la troisi\u00e8me m\u00e9thode, nous sommes sur le bouton annuler. public View . OnClickListener eventBtnAnnuler = new View . OnClickListener () { @Override public void onClick ( View v ) { Intent retourMenu = new Intent ( AjoutProspectActivity . this , MenuActivity . class ); retourMenu . putExtra ( \"employee\" , lEmployee ); startActivity ( retourMenu ); } }; Elle nous permet de revenir sur la page pr\u00e9c\u00e9dente et donc d'annuler toute tentative d'ajout de prospect. Aide aux entr\u00e9es La m\u00e9thode d'aide aux entr\u00e9es va permettre d'informer l'utilisateur sur ce qu'il doit \u00e9crire dans chacune des zones de texte. Pour cela, l'utilisateur doit double cliquer sur un des EditText. public void infosEntrees ( View v ){ LinearLayout preInfosAjoutProspect = findViewById ( R . id . preInfosAjoutProspect ); preInfosAjoutProspect . setVisibility ( View . GONE ); LinearLayout InfosAjoutProspect = findViewById ( R . id . InfosAjoutProspect ); InfosAjoutProspect . setVisibility ( View . VISIBLE ); noteInfos = ( TextView ) findViewById ( R . id . noteInformations ); switch ( v . getId ()){ case R . id . RaisonSociale : noteInfos . setText ( \"La Raison sociale est le nom d'une soci\u00e9t\u00e9.\\nSa taille maximale est de 50.\\nSont autoris\u00e9s :\\n- Les chiffres et les lettres.\\n- Les signes '/', '@', '*'.\" ); break ; case R . id . Siren : noteInfos . setText ( \"Le Siren est le num\u00e9ro d'identification d'une entreprise.\\nSa taille maximale est de 9.\\nSont autoris\u00e9s :\\n- Les chiffres.\" ); break ; case R . id . Nom : noteInfos . setText ( \"Le Nom a une taille maximale de 35.\\nSont autoris\u00e9s :\\n- Les lettres.\\n- Le signe '-'.\" ); break ; case R . id . Prenom : noteInfos . setText ( \"Le Pr\u00e9nom a une taille maximale de 25.\\nSont autoris\u00e9s :\\n- Les lettres.\\n- Le signe '-'.\" ); break ; case R . id . Telephone : noteInfos . setText ( \"Le Num\u00e9ro de t\u00e9l\u00e9phone a une taille maximale de 14.\\nIl peut commencer par '0033','33','0' et est suivi de 8 chiffres\\nSont autoris\u00e9s :\\n- Les chiffres.\" ); break ; case R . id . Email : noteInfos . setText ( \"L'Adresse e-mail a une taille maximale de 100.\\nElle doit suivre l'exemple suivant : ABC@example.com\\nSont autoris\u00e9s :\\n- Les chiffres et les lettres.\\n- Les signes '.','-','_'\" ); break ; case R . id . Notes : noteInfos . setText ( \"La Note a une taille maximale de 2.\\nElle doit \u00eatre comprise entre 0 et 20.\\nSont autoris\u00e9s :\\n- Les chiffres\" ); break ; } }; Le rectangle indiquant qu'il doit double cliquer disparait pour laisser apparaitre le vrai rectangle d'une taille plus grande contenant les bonnes informations. Exemple : L'utilisateur appuie sur la raison sociale.","title":"Ajouter un Prospect"},{"location":"javaAndroid/ajoutProspect/#ajouter-un-prospect","text":"","title":"Ajouter un Prospect"},{"location":"javaAndroid/ajoutProspect/#introduction","text":"La classe AjoutProspectActivity h\u00e9rite de AppCompatActivity . Sont but est de permettre la cr\u00e9ation d'un nouveau prospect. Elle utilise la page layout activity_addprospect en tant que FrontEnd.","title":"Introduction"},{"location":"javaAndroid/ajoutProspect/#methodes","text":"","title":"M\u00e9thodes"},{"location":"javaAndroid/ajoutProspect/#evenements-boutons","text":"Pour ce qui est des \u00e9v\u00e9nenements en rapport avec les boutons nous en avons 3. Le Premier intitul\u00e9 eventBtnRechercherEntreprise est li\u00e9 au bouton Rechercher. public View . OnClickListener eventBtnRechercherEntreprise = new View . OnClickListener () { @Override public void onClick ( View v ) { ApiGouv apiGouv = new ApiGouv (); long siren = apiGouv . getSirenWithName ( raisonSociale . getText (). toString ()); String sirenString = Long . toString ( siren ); siretText . setText ( sirenString , TextView . BufferType . EDITABLE ); boiteMessage ( apiGouv . getResult ()); } }; Il permet quand on clique dessus de rechercher gr\u00e2ce \u00e0 l'API du gouvernement sur les entreprises, le num\u00e9ro Siren de la raison sociale qu'on a \u00e9crit dans le EditText au dessus du bouton. Pour ce qui est du deuxi\u00e8me, il est intitul\u00e9 eventBtnEnregistrer et est li\u00e9 au bouton Enregistrer. La m\u00e9thode fais 115 lignes. (en contant les sauts de lignes et les commentaires) public View . OnClickListener eventBtnEnregistrer = new View . OnClickListener () { @Override public void onClick ( View v ) { /* R\u00e9cup\u00e9ration de ce qu'a \u00e9crit l'utilisateur dans les EditText puis on les transforment en chaine de caract\u00e8re qu'on stockent dans de nouvelles variables */ EditText raisonSocialeProspectTxt = ( EditText ) findViewById ( R . id . RaisonSociale ); String raisonSocialeProspect = raisonSocialeProspectTxt . getText (). toString (); EditText sirenProspectTxt = ( EditText ) findViewById ( R . id . Siren ); String sirenProspect = sirenProspectTxt . getText (). toString (); EditText nomProspectTxt = ( EditText ) findViewById ( R . id . Nom ); String nomProspect = nomProspectTxt . getText (). toString (); EditText prenomProspectTxt = ( EditText ) findViewById ( R . id . Prenom ); String prenomProspect = prenomProspectTxt . getText (). toString (); EditText mailProspectTxt = ( EditText ) findViewById ( R . id . Email ); String mailProspect = mailProspectTxt . getText (). toString (); EditText telProspectTxt = ( EditText ) findViewById ( R . id . Telephone ); String telProspect = telProspectTxt . getText (). toString (); EditText noteProspectTxt = ( EditText ) findViewById ( R . id . Notes ); String noteProspect = noteProspectTxt . getText (). toString (); /* Initialisation des Regex pour faire des tests par rapport aux entr\u00e9es de l'utilisateur */ String regexRaisonSociale = \"[A-Za-z0-9\\\\\u00e9\\\\\u00e8\\\\\u00ea\\\\\u00ef\\\\@\\\\/\\\\*\\\\-]+$\" ; String regexSiren = \"[0-9]{9}|0\" ; String regexNomPrenom = \"[A-Za-z\\\\\u00e9\\\\\u00e8\\\\\u00ea\\\\\u00ef\\\\-]+$\" ; String regexEmail = \"[a-zA-Z0-9._-]+@[a-z]+\\\\.+[a-z]+\" ; String regexPhoneNumber = \"(33|0033|0)[1-9][0-9]{8}$\" ; String regexNote = \"[0-9]|1[0-9]|20\" ; String regexSpace = \"(\\\\s+)$\" ; long sirenProspectTest = 0 ; String telProspectTest = \"\" ; int noteProspectTest = 0 ; String errorMessage = \"\" ; /* Cr\u00e9ation des tests sur les entr\u00e9es de l'utilisateur */ if ( nomProspectTxt . length () != 0 && prenomProspectTxt . length () != 0 && sirenProspectTxt . length () != 0 && raisonSocialeProspectTxt . length () != 0 && mailProspectTxt . length () != 0 ) { Prospect newProspect = new Prospect (); if ( raisonSocialeProspect . matches ( regexRaisonSociale ) && ! raisonSocialeProspect . matches ( regexSpace )) { newProspect . setRaisonSocial ( raisonSocialeProspect ); } else { errorMessage += \"- Raison Sociale \\n\" ; } if ( sirenProspect . matches ( regexSiren ) && ! sirenProspect . matches ( regexSpace )) { sirenProspectTest = Long . parseLong ( sirenProspect ); newProspect . setSiret ( sirenProspectTest ); } else { errorMessage += \"- Siren \\n\" ; } if ( prenomProspect . matches ( regexNomPrenom ) && ! prenomProspect . matches ( regexSpace )) { newProspect . setPrenom ( prenomProspect ); } else { errorMessage += \"- Pr\u00e9nom \\n\" ; } if ( nomProspect . matches ( regexNomPrenom ) && ! nomProspect . matches ( regexSpace )) { newProspect . setNom ( nomProspect ); } else { errorMessage += \"- Nom \\n\" ; } if ( mailProspect . matches ( regexEmail ) && ! mailProspect . matches ( regexSpace )) { newProspect . setMail ( mailProspect ); } else { errorMessage += \"- Mail \\n\" ; } if ( telProspect . length () == 0 || telProspect . matches ( regexPhoneNumber )) { telProspectTest = ( telProspect . length () == 0 ) ? \"0\" : telProspect ; newProspect . setTel ( telProspectTest ); } else { errorMessage += \"- T\u00e9l\u00e9phone \\n\" ; } if ( noteProspect . length () == 0 || ( noteProspect . matches ( regexNote ))) { noteProspectTest = ( noteProspect . length () == 0 ) ? 0 : Integer . parseInt ( noteProspect ); newProspect . setNotes ( noteProspectTest ); } else { errorMessage += \"- Note \\n\" ; } newProspect . setIsUpdate ( false ); if ( errorMessage . length () == 0 ){ dataBase . getProspectBdd (). add ( newProspect ); Intent retourMenu = new Intent ( AjoutProspectActivity . this , MenuActivity . class ); retourMenu . putExtra ( \"employee\" , lEmployee ); startActivity ( retourMenu ); } else { boiteMessage ( \"Sont invalides :\\n\" + errorMessage ); } } else { boiteMessage ( \"L'un des champs suivants est vide.\\n\" + \"\\n\" + \"Sont obligatoires : \\n\" + \"La Raison Sociale de l'entreprise\\n\" + \"Le Siret\\n\" + \"Le Nom\\n\" + \"Le Pr\u00e9nom\\n\" + \"Le Mail\" ); } } }; Il y a 3 parties coup\u00e9es par des commentaires. La premi\u00e8re qui permet d'obtenir sous la forme d'une chaine de caract\u00e8re ce que l'utilisateur a \u00e9crit dans chacun des EditText. La seconde qui met en place les Regex pour les prochains tests. Et finalement les tests sur ce que l'usager \u00e0 mis compar\u00e9s aux Regex. Pour la troisi\u00e8me m\u00e9thode, nous sommes sur le bouton annuler. public View . OnClickListener eventBtnAnnuler = new View . OnClickListener () { @Override public void onClick ( View v ) { Intent retourMenu = new Intent ( AjoutProspectActivity . this , MenuActivity . class ); retourMenu . putExtra ( \"employee\" , lEmployee ); startActivity ( retourMenu ); } }; Elle nous permet de revenir sur la page pr\u00e9c\u00e9dente et donc d'annuler toute tentative d'ajout de prospect.","title":"\u00c9v\u00e9nements Boutons"},{"location":"javaAndroid/ajoutProspect/#aide-aux-entrees","text":"La m\u00e9thode d'aide aux entr\u00e9es va permettre d'informer l'utilisateur sur ce qu'il doit \u00e9crire dans chacune des zones de texte. Pour cela, l'utilisateur doit double cliquer sur un des EditText. public void infosEntrees ( View v ){ LinearLayout preInfosAjoutProspect = findViewById ( R . id . preInfosAjoutProspect ); preInfosAjoutProspect . setVisibility ( View . GONE ); LinearLayout InfosAjoutProspect = findViewById ( R . id . InfosAjoutProspect ); InfosAjoutProspect . setVisibility ( View . VISIBLE ); noteInfos = ( TextView ) findViewById ( R . id . noteInformations ); switch ( v . getId ()){ case R . id . RaisonSociale : noteInfos . setText ( \"La Raison sociale est le nom d'une soci\u00e9t\u00e9.\\nSa taille maximale est de 50.\\nSont autoris\u00e9s :\\n- Les chiffres et les lettres.\\n- Les signes '/', '@', '*'.\" ); break ; case R . id . Siren : noteInfos . setText ( \"Le Siren est le num\u00e9ro d'identification d'une entreprise.\\nSa taille maximale est de 9.\\nSont autoris\u00e9s :\\n- Les chiffres.\" ); break ; case R . id . Nom : noteInfos . setText ( \"Le Nom a une taille maximale de 35.\\nSont autoris\u00e9s :\\n- Les lettres.\\n- Le signe '-'.\" ); break ; case R . id . Prenom : noteInfos . setText ( \"Le Pr\u00e9nom a une taille maximale de 25.\\nSont autoris\u00e9s :\\n- Les lettres.\\n- Le signe '-'.\" ); break ; case R . id . Telephone : noteInfos . setText ( \"Le Num\u00e9ro de t\u00e9l\u00e9phone a une taille maximale de 14.\\nIl peut commencer par '0033','33','0' et est suivi de 8 chiffres\\nSont autoris\u00e9s :\\n- Les chiffres.\" ); break ; case R . id . Email : noteInfos . setText ( \"L'Adresse e-mail a une taille maximale de 100.\\nElle doit suivre l'exemple suivant : ABC@example.com\\nSont autoris\u00e9s :\\n- Les chiffres et les lettres.\\n- Les signes '.','-','_'\" ); break ; case R . id . Notes : noteInfos . setText ( \"La Note a une taille maximale de 2.\\nElle doit \u00eatre comprise entre 0 et 20.\\nSont autoris\u00e9s :\\n- Les chiffres\" ); break ; } }; Le rectangle indiquant qu'il doit double cliquer disparait pour laisser apparaitre le vrai rectangle d'une taille plus grande contenant les bonnes informations. Exemple : L'utilisateur appuie sur la raison sociale.","title":"Aide aux entr\u00e9es"},{"location":"javaAndroid/frontEnd/","text":"","title":"frontEnd"},{"location":"javaAndroid/menuActivity/","text":"Menu Activity Introduction La classe MenuActivity permet d'avoir un aper\u00e7u des prospects avec une recherche par rapport \u00e0 ceux-ci, ainsi que leurs informations en d\u00e9tails. Elle permet aussi de synchroniser les donn\u00e9es avec le serveur et d'acc\u00e9der \u00e0 la page d'ajout de prospect. Le FrontEnd, layout principal qui lui est li\u00e9 est intitul\u00e9 activity_menu . Aper\u00e7u depuis Android Studio avant lancement : Affichage des prospects et leurs d\u00e9tails Affichage On affiche les prospects sur le Menu dans la partie basse en passant par un tableau qui contient un recycler view mais c'est bien plus complexe ! Pour que cela fonctionne nous avons besoin du layout item_layout et de la classe ShowProspectAdaptater . Le xml item_layout contient uniquement une table avec une ligne et 3 colonnes repr\u00e9sent\u00e9s par des TextView, gr\u00e2ce \u00e0 ShowProspectAdaptater nous allons pouvoir g\u00e9n\u00e9rer plusieurs lignes ayant pour design le xml cit\u00e9 juste avant (le design est simple, on a juste une bordure bottom bleu depuis un background drawable). La classe ShowProspectAdaptater est compos\u00e9e de 4 m\u00e9thodes : public class ViewHolder extends RecyclerView . ViewHolder { TextView nom_prospect , prenom_prospect , entreprise_prospect ; TableRow row_prospect ; public ViewHolder ( @NonNull View itemView ){ super ( itemView ); nom_prospect = itemView . findViewById ( R . id . nom_prospect ); prenom_prospect = itemView . findViewById ( R . id . prenom_prospect ); entreprise_prospect = itemView . findViewById ( R . id . entreprise_prospect ); row_prospect = itemView . findViewById ( R . id . tableRowProspect ); } } La premi\u00e8re permet de mettre en place un ViewHolder qui h\u00e9rite de RecyclerView.ViewHolder , on y appel ici les id des colonnes ainsi que de la ligne disponible dans le xml item_layout . @Override public int getItemCount () { if ( prospectList != null ){ if ( prospectList . size () <= 5 ){ return prospectList . size (); } else { return 5 ; } } else { return 0 ; } } La seconde va rechercher la taille de la liste de prospect c'est-\u00e0-dire combien de prospect sont existants, si le tableau prospectList est null alors on va r\u00e9cup\u00e9rer la valeur 0, si on en a moins ou 5 on en r\u00e9cup\u00e9re la taille de la liste et sinon dans le cas o\u00f9 on en a plus de 5, on r\u00e9cup\u00e9re 5. @Override public void onBindViewHolder ( @NonNull ShowProspectAdaptater . ViewHolder holder , int position ) { if ( prospectList != null && prospectList . size () > 0 ){ Prospect model = prospectList . get ( position ); holder . nom_prospect . setText ( model . getNom ()); holder . prenom_prospect . setText ( model . getPrenom ()); holder . entreprise_prospect . setText ( model . getRaisonSocial ()); holder . row_prospect . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { holder . row_prospect . setBackgroundColor ( Color . rgb ( 180 , 180 , 180 )); interfaceClickable . setClick ( position , prospectList ); } }); } else { return ; } } La troisi\u00e8me quant \u00e0 elle prend en param\u00e8tre deux choses, le ViewHolder cr\u00e9er auparavant ainsi qu'une position. On va v\u00e9rifier si la taille du tableau prospectList n'est pas null et si il est sup\u00e9rieur \u00e0 0 sinon on ne retourne rien. Puis on cr\u00e9er un prospect \"model\" qui va prendre les informations du prospect dans le tableau qui est \u00e0 la position prise en param\u00e8tre pour ensuite stock\u00e9 son nom, pr\u00e9nom, sa raison sociale dans des holders. (Nous reviendrons sur le setOnClickListener dans la partie d\u00e9tail) public ViewHolder onCreateViewHolder ( @NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( context ). inflate ( R . layout . item_layout , parent , false ); return new ViewHolder ( view ); } Finalement un onCreateViewHolder avec en param\u00e8tre parent et viewType va retourn\u00e9 le ViewHoler contenant la vue. Ce qui va permettre en dernier l'affichage est disponible dans la classe MenuActivity , une m\u00e9thode setRecyclerView va mettre les prospects avec un model qui est la cr\u00e9ation de la classe ShowProspectAdaptater . private void setRecyclerView ( ArrayList < Prospect > lesProspects ) { recycler_view . setHasFixedSize ( true ); recycler_view . setLayoutManager ( new LinearLayoutManager ( this )); model = new ShowProspectAdaptater ( this , lesProspects , interfaceClickable ); recycler_view . setAdapter ( model ); } En r\u00e9sultat par exemple avec 3 prospect, nous obtenons ceci : D\u00e9tails Pour ce qui est de leurs d\u00e9tails, dans le xml correspondant \u00e0 la page menu : activity_menu nous voyons au d\u00e9but de la page un grand carr\u00e9 bleu faisant la page vide, mais en faite il y a \u00e0 cette place un LinearLayout cach\u00e9 gr\u00e2ce \u00e0 la ligne android:visibility=\"gone\" celui-ci a l'id : infosProspectLayout. Il contient ceci : D\u00e8s le d\u00e9but de la classe MenuActivity , dans le onCreate, nous avons une interface clicquable. interfaceClickable = new onClickInterface () { TextView nomInfos = ( TextView ) findViewById ( R . id . nomProspect ); TextView prenomInfos = ( TextView ) findViewById ( R . id . prenomProspect ); TextView raisonSocialeInfos = ( TextView ) findViewById ( R . id . raisonSocialeProspect ); TextView sirenInfos = ( TextView ) findViewById ( R . id . sirenProspect ); TextView mailInfos = ( TextView ) findViewById ( R . id . mailProspect ); TextView telephoneInfos = ( TextView ) findViewById ( R . id . telephoneProspect ); TextView noteInfos = ( TextView ) findViewById ( R . id . noteProspect ); boolean visible ; @Override public void setClick ( int position , List < Prospect > lesProspects ) { Prospect prospect = lesProspects . get ( position ); nomInfos . setText ( prospect . getNom ()); prenomInfos . setText ( prospect . getPrenom ()); raisonSocialeInfos . setText ( prospect . getRaisonSocial ()); sirenInfos . setText ( String . valueOf ( prospect . getSiret ())); mailInfos . setText ( prospect . getMail ()); telephoneInfos . setText ( prospect . getTel ()); noteInfos . setText ( String . valueOf ( prospect . getNotes ())); if ( infosProspectLayout . getVisibility () == View . GONE ){ visible = false ; } else { visible = true ; } filtresLayout . setVisibility ( View . GONE ); TransitionManager . beginDelayedTransition ( infosProspectLayout ); visible = ! visible ; infosProspectLayout . setVisibility ( visible ? View . VISIBLE : View . GONE ); } }; Nous cr\u00e9ons ici une interface clicquable c'est-\u00e0-dire que nous utilisons une interface nomm\u00e9 onClickInterface contenant uniquement ceci : public interface onClickInterface { void setClick ( int position , List < Prospect > lesProspects ); } Elle a ici diff\u00e9rent TextView correspondant aux informations d\u00e9taill\u00e9es des prospects ainsi qu'un bool\u00e9en \"visible\" sans valeur. D\u00e8s que l'on va cliquer sur celle-ci, nous allons obtenir la position du prospect dans la liste (tableau) lesProspects pour ajouter ensuite \u00e0 l'int\u00e9rieur des TextView les informations d'un prospect. Le infosProspectLayout alors va avoir sa visibilit\u00e9 modifi\u00e9, il va apparaitre ou disparaitre en fonction de si il est ou non pr\u00e9sent, nous parlons ici aussi d'un filtresLayout mais cela fait partie de la recherche de prospect. Nous avions vu auparavant ce code ci-dessous dans la classe ShowProspectAdaptater . holder . row_prospect . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { interfaceClickable . setClick ( position , prospectList ); } }); Il met en place le fait que ce soit sur les lignes du tableau que nous allons cliquer gr\u00e2ce \u00e0 l'interface cliquable. Exemple de clic sur un prospect (le Siren n'est pas correct, le prospect avait \u00e9t\u00e9 fait avant les r\u00e8gles sur l'ajout d'un prospect) : Recherche de prospect Hormis la partie infosProspectLayout cach\u00e9e, une autre l'est aussi, c'est filtresLayout , elle ressemble \u00e0 \u00e7a : Elle va permettre de faire une recherche qui va actualiser la liste des prospects et dont affich\u00e9 que ce que l'utilisateur veut. La premi\u00e8re m\u00e9thode est un \u00e9v\u00e9nement de bouton, le bouton de la page d'accueil \"Rechercher\" le provoque. public View . OnClickListener eventBtnRechercherVisibility = new View . OnClickListener () { boolean visible ; @Override public void onClick ( View v ) { infosProspectLayout . setVisibility ( View . GONE ); TransitionManager . beginDelayedTransition ( filtresLayout ); visible = ! visible ; filtresLayout . setVisibility ( visible ? View . VISIBLE : View . GONE ); } }; Il permet de changer la visibilit\u00e9 du filtresLayout en visible ou non si l'on reclick dessus. Ensuite il est possible d'\u00e9crire trois crit\u00e8re, le nom, le pr\u00e9nom et la raison sociale. On peut \u00e9crire quelque chose dans un seul ou m\u00eame dans les trois et d\u00e8s que l'on va appuyer sur le bouton Lancer la Recherche la m\u00e9thode suivant va se lancer : public View . OnClickListener eventBtnRechercher = new View . OnClickListener () { @Override public void onClick ( View v ) { ArrayList < Prospect > lesProspects = dataBase . getProspectBdd (). getProspects ( nomFiltre . getText (). toString (), prenomFiltre . getText (). toString (), entrepriseFiltre . getText (). toString (), true ); setRecyclerView ( lesProspects ); } }; Elle r\u00e9cup\u00e8re une liste de prospect lesProspects qui est le r\u00e9sultat d'un appel d'une m\u00e9thode de la classe ProspectBDD . /** * R\u00e9cup\u00e8re un tableau de prospects * * @param nom String ou null : le nom du prospect * @param prenom String ou null : le prenom du prospect * @param raisonSocial String ou null : la raison social de l'entreprise * @param isUpdate boolean : true si on veux tous les prospects correspondant aux autres crit\u00e8res ou false si on souhaite que les prospects non synchroniser avec le serveur * @return ArrayLsit<Prospect> ou null : la liste des prorpects correspondant aux crit\u00e8res ou null s'il n'existe aucun prospect correspondant */ public ArrayList < Prospect > getProspects ( String nom , String prenom , String raisonSocial , boolean isUpdate ) { open (); String [] params = new String [ ( nom != null ? 1 : 0 ) + ( prenom != null ? 1 : 0 ) + ( raisonSocial != null ? 1 : 0 ) ] ; int paramIndex = 0 ; String where = \"\" ; if ( nom != null ) { where = NOM_COL + \" LIKE ?\" ; params [ paramIndex ++] = nom + \"%\" ; } if ( prenom != null ) { if ( ! where . equals ( \"\" )) where = where + \" AND \" ; where = where + PRENOM_COL + \" LIKE ?\" ; params [ paramIndex ++] = prenom + \"%\" ; } if ( raisonSocial != null ) { if ( ! where . equals ( \"\" )) where = where + \" AND \" ; where = where + RAISON_SOCIAL_COL + \" LIKE ?\" ; params [ paramIndex ++] = raisonSocial + \"%\" ; } if ( ! isUpdate ) { if ( ! where . equals ( \"\" )) where = where + \" AND \" ; where = where + IS_UPDATE_COL + \" = 0\" ; } Cursor c = getBdd (). query ( getTableName (), new String [] { NOM_COL , PRENOM_COL , TEL_COL , MAIL_COL , NOTES_COL , SIRET_COL , RAISON_SOCIAL_COL , IS_UPDATE_COL }, where , params , null , null , null ); if ( c == null || c . getCount () == 0 ) { return null ; } c . moveToFirst (); Prospect leProspect = cursorToProspect ( c ); ArrayList < Prospect > lesProspects = new ArrayList <> (); lesProspects . add ( leProspect ); if ( c . getCount () > 1 ) { for ( int i = 1 ; i < c . getCount (); i ++ ) { c . moveToNext (); lesProspects . add ( cursorToProspect ( c )); } } c . close (); close (); return lesProspects ; } La m\u00e9thode va nous permettre de faire des recherches SQL par rapport aux entr\u00e9es de l'utilisateur. Nous nous retrouvons finalement avec le tableau affichant les prospects avec les nouveaux correspondant aux recherches. Malgr\u00e9 tout si nous voulosn annuler les filtres alors il suffit d'appuyer sur le bouton Effacer les crit\u00e8res . public void eventBtnClearFiltres ( View v ) { nomFiltre . setText ( \"\" ); prenomFiltre . setText ( \"\" ); entrepriseFiltre . setText ( \"\" ); ArrayList < Prospect > lesProspects = dataBase . getProspectBdd (). getProspects ( null , null , null , true ); setRecyclerView ( lesProspects ); } Il remet le contenu des EditText vide et r\u00e9tabli la liste lesProspects avec les informations de base. Synchronisation avec le serveur externe Ce diagramme de s\u00e9quence repr\u00e9sente la r\u00e9cup\u00e9ration des prospects depuis l'api au format json et de l'ajout en base de donn\u00e9es local. Et dans un second temps la r\u00e9cup\u00e9ration des prospects en base de donn\u00e9es SQLite puis du formatage en json pour l'envoi au serveur. sequenceDiagram actor Commercial Commercial ->>+ Activity Menu: bouton synchroniser Activity Menu ->>+ APIBdd: callWebService(getAllProspects) APIBdd -->>- Activity Menu: JSONArray json loop updateBddProspects(json) Activity Menu -)+ Prospect: create with json data Prospect -->>- Activity Menu: object Activity Menu ->>+ DAO: add Prospect DAO -->>- Activity Menu: resultat insertion end Activity Menu ->>+ DAO: getProspect DAO -->>- Activity Menu: ArrayList<Prospect> Activity Menu ->>+ APIBdd: createJsonProspects(lesProspects) APIBdd -->>- Activity Menu: JSONArray jsonProspects Activity Menu ->> APIBdd: postJsonProspect(\"InsertProspect\", jsonProspects) Activity Menu -->>- Commercial: boiteMessage(resultApi) L'\u00e9v\u00e8nement du bouton est d\u00e9clar\u00e9 dans eventBtnSynchroniser . La date de mise \u00e0 jour permet de r\u00e9cup\u00e9rer les prospects cr\u00e9er \u00e0 une date ult\u00e9rieure \u00e0 celle de la mise \u00e0 jour et donc limiter le nombres d'informations transmis en bande passante. Pour le POST : application envoie seulement les prospects pour lesquelles la valeur isupdate de la colonne est \u00e0 false, il s'agit d'une valeur boolean pour savoir s'il le prospect est d\u00e9j\u00e0 synchronis\u00e9 avec le serveur externe. public View . OnClickListener eventBtnSynchroniser = new View . OnClickListener () { @Override public void onClick ( View v ) { loading . startLoadingDialog (); SimpleDateFormat formatter = new SimpleDateFormat ( \"yyyy-MM-dd HH:mm:ss\" ); formatter . setTimeZone ( TimeZone . getTimeZone ( \"UTC\" )); Date date = new Date (); String dateMiseAjour = formatter . format ( date ); ApiBdd api = new ApiBdd (); api . callWebService ( \"getAllProspects.php?date=\" + lEmployee . getDateMiseAjour (). replace ( \":\" , \"!\" )); JSONArray json = api . getJsonData (); updateBddProspects ( json ); ArrayList < Prospect > lesProspects = dataBase . getProspectBdd (). getProspects ( null , null , null , false ); //getAllProspects(); if ( lesProspects != null ){ JSONArray jsonProspects = api . createJsonProspects ( lesProspects ); api . postJsonProspect ( \"insertProspect.php?date=\" + lEmployee . getDateMiseAjour (). replace ( \":\" , \"!\" ), jsonProspects . toString ()); } lEmployee . setDateMiseAjour ( dateMiseAjour ); dataBase . getEmployeeBdd (). update ( lEmployee ); loading . dismissDialog (); boiteMessage ( api . getResult ()); setRecyclerView ( dataBase . getProspectBdd (). getProspects ( null , null , null , true )); } }; Pour obtenir le bon format des donn\u00e9es en json et mettre \u00e0 jour le fichier SQLite la m\u00e9thode updateBddProspects d\u00e9compose l'objet et insert en bdd les prospects. Pour cr\u00e9er le format de donn\u00e9es \u00e0 envoyer on utilise la m\u00e9thode createJsonProspects(ArrayList<Prospect> lesProspects) . /** * Formate une liste de prospect en json * * @param lesProspects ArrayList : la liste de prospects * @return JsonArray : les prospects au format json */ public JSONArray createJsonProspects ( ArrayList < Prospect > lesProspects ) { //Creating a JSONObject object JSONArray jsonArray = new JSONArray (); try { for ( Prospect prospect : lesProspects ) { JSONObject jsonObject = new JSONObject (); //Inserting key-value pairs into the json object jsonObject . put ( \"id\" , \"default\" ); jsonObject . put ( \"nom\" , prospect . getNom ()); jsonObject . put ( \"prenom\" , prospect . getPrenom ()); jsonObject . put ( \"mail\" , prospect . getMail ()); jsonObject . put ( \"tel\" , prospect . getTel ()); jsonObject . put ( \"note\" , prospect . getNotes ()); jsonObject . put ( \"siret\" , prospect . getSiret ()); jsonObject . put ( \"raisonsocial\" , prospect . getRaisonSocial ()); jsonArray . put ( jsonObject ); } } catch ( Exception e ) { e . printStackTrace (); } return jsonArray ; } Le bouton Ajouter change l'activit\u00e9 vers AjoutProspectActivity","title":"Menu Activity"},{"location":"javaAndroid/menuActivity/#menu-activity","text":"","title":"Menu Activity"},{"location":"javaAndroid/menuActivity/#introduction","text":"La classe MenuActivity permet d'avoir un aper\u00e7u des prospects avec une recherche par rapport \u00e0 ceux-ci, ainsi que leurs informations en d\u00e9tails. Elle permet aussi de synchroniser les donn\u00e9es avec le serveur et d'acc\u00e9der \u00e0 la page d'ajout de prospect. Le FrontEnd, layout principal qui lui est li\u00e9 est intitul\u00e9 activity_menu . Aper\u00e7u depuis Android Studio avant lancement :","title":"Introduction"},{"location":"javaAndroid/menuActivity/#affichage-des-prospects-et-leurs-details","text":"","title":"Affichage des prospects et leurs d\u00e9tails"},{"location":"javaAndroid/menuActivity/#affichage","text":"On affiche les prospects sur le Menu dans la partie basse en passant par un tableau qui contient un recycler view mais c'est bien plus complexe ! Pour que cela fonctionne nous avons besoin du layout item_layout et de la classe ShowProspectAdaptater . Le xml item_layout contient uniquement une table avec une ligne et 3 colonnes repr\u00e9sent\u00e9s par des TextView, gr\u00e2ce \u00e0 ShowProspectAdaptater nous allons pouvoir g\u00e9n\u00e9rer plusieurs lignes ayant pour design le xml cit\u00e9 juste avant (le design est simple, on a juste une bordure bottom bleu depuis un background drawable). La classe ShowProspectAdaptater est compos\u00e9e de 4 m\u00e9thodes : public class ViewHolder extends RecyclerView . ViewHolder { TextView nom_prospect , prenom_prospect , entreprise_prospect ; TableRow row_prospect ; public ViewHolder ( @NonNull View itemView ){ super ( itemView ); nom_prospect = itemView . findViewById ( R . id . nom_prospect ); prenom_prospect = itemView . findViewById ( R . id . prenom_prospect ); entreprise_prospect = itemView . findViewById ( R . id . entreprise_prospect ); row_prospect = itemView . findViewById ( R . id . tableRowProspect ); } } La premi\u00e8re permet de mettre en place un ViewHolder qui h\u00e9rite de RecyclerView.ViewHolder , on y appel ici les id des colonnes ainsi que de la ligne disponible dans le xml item_layout . @Override public int getItemCount () { if ( prospectList != null ){ if ( prospectList . size () <= 5 ){ return prospectList . size (); } else { return 5 ; } } else { return 0 ; } } La seconde va rechercher la taille de la liste de prospect c'est-\u00e0-dire combien de prospect sont existants, si le tableau prospectList est null alors on va r\u00e9cup\u00e9rer la valeur 0, si on en a moins ou 5 on en r\u00e9cup\u00e9re la taille de la liste et sinon dans le cas o\u00f9 on en a plus de 5, on r\u00e9cup\u00e9re 5. @Override public void onBindViewHolder ( @NonNull ShowProspectAdaptater . ViewHolder holder , int position ) { if ( prospectList != null && prospectList . size () > 0 ){ Prospect model = prospectList . get ( position ); holder . nom_prospect . setText ( model . getNom ()); holder . prenom_prospect . setText ( model . getPrenom ()); holder . entreprise_prospect . setText ( model . getRaisonSocial ()); holder . row_prospect . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { holder . row_prospect . setBackgroundColor ( Color . rgb ( 180 , 180 , 180 )); interfaceClickable . setClick ( position , prospectList ); } }); } else { return ; } } La troisi\u00e8me quant \u00e0 elle prend en param\u00e8tre deux choses, le ViewHolder cr\u00e9er auparavant ainsi qu'une position. On va v\u00e9rifier si la taille du tableau prospectList n'est pas null et si il est sup\u00e9rieur \u00e0 0 sinon on ne retourne rien. Puis on cr\u00e9er un prospect \"model\" qui va prendre les informations du prospect dans le tableau qui est \u00e0 la position prise en param\u00e8tre pour ensuite stock\u00e9 son nom, pr\u00e9nom, sa raison sociale dans des holders. (Nous reviendrons sur le setOnClickListener dans la partie d\u00e9tail) public ViewHolder onCreateViewHolder ( @NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( context ). inflate ( R . layout . item_layout , parent , false ); return new ViewHolder ( view ); } Finalement un onCreateViewHolder avec en param\u00e8tre parent et viewType va retourn\u00e9 le ViewHoler contenant la vue. Ce qui va permettre en dernier l'affichage est disponible dans la classe MenuActivity , une m\u00e9thode setRecyclerView va mettre les prospects avec un model qui est la cr\u00e9ation de la classe ShowProspectAdaptater . private void setRecyclerView ( ArrayList < Prospect > lesProspects ) { recycler_view . setHasFixedSize ( true ); recycler_view . setLayoutManager ( new LinearLayoutManager ( this )); model = new ShowProspectAdaptater ( this , lesProspects , interfaceClickable ); recycler_view . setAdapter ( model ); } En r\u00e9sultat par exemple avec 3 prospect, nous obtenons ceci :","title":"Affichage"},{"location":"javaAndroid/menuActivity/#details","text":"Pour ce qui est de leurs d\u00e9tails, dans le xml correspondant \u00e0 la page menu : activity_menu nous voyons au d\u00e9but de la page un grand carr\u00e9 bleu faisant la page vide, mais en faite il y a \u00e0 cette place un LinearLayout cach\u00e9 gr\u00e2ce \u00e0 la ligne android:visibility=\"gone\" celui-ci a l'id : infosProspectLayout. Il contient ceci : D\u00e8s le d\u00e9but de la classe MenuActivity , dans le onCreate, nous avons une interface clicquable. interfaceClickable = new onClickInterface () { TextView nomInfos = ( TextView ) findViewById ( R . id . nomProspect ); TextView prenomInfos = ( TextView ) findViewById ( R . id . prenomProspect ); TextView raisonSocialeInfos = ( TextView ) findViewById ( R . id . raisonSocialeProspect ); TextView sirenInfos = ( TextView ) findViewById ( R . id . sirenProspect ); TextView mailInfos = ( TextView ) findViewById ( R . id . mailProspect ); TextView telephoneInfos = ( TextView ) findViewById ( R . id . telephoneProspect ); TextView noteInfos = ( TextView ) findViewById ( R . id . noteProspect ); boolean visible ; @Override public void setClick ( int position , List < Prospect > lesProspects ) { Prospect prospect = lesProspects . get ( position ); nomInfos . setText ( prospect . getNom ()); prenomInfos . setText ( prospect . getPrenom ()); raisonSocialeInfos . setText ( prospect . getRaisonSocial ()); sirenInfos . setText ( String . valueOf ( prospect . getSiret ())); mailInfos . setText ( prospect . getMail ()); telephoneInfos . setText ( prospect . getTel ()); noteInfos . setText ( String . valueOf ( prospect . getNotes ())); if ( infosProspectLayout . getVisibility () == View . GONE ){ visible = false ; } else { visible = true ; } filtresLayout . setVisibility ( View . GONE ); TransitionManager . beginDelayedTransition ( infosProspectLayout ); visible = ! visible ; infosProspectLayout . setVisibility ( visible ? View . VISIBLE : View . GONE ); } }; Nous cr\u00e9ons ici une interface clicquable c'est-\u00e0-dire que nous utilisons une interface nomm\u00e9 onClickInterface contenant uniquement ceci : public interface onClickInterface { void setClick ( int position , List < Prospect > lesProspects ); } Elle a ici diff\u00e9rent TextView correspondant aux informations d\u00e9taill\u00e9es des prospects ainsi qu'un bool\u00e9en \"visible\" sans valeur. D\u00e8s que l'on va cliquer sur celle-ci, nous allons obtenir la position du prospect dans la liste (tableau) lesProspects pour ajouter ensuite \u00e0 l'int\u00e9rieur des TextView les informations d'un prospect. Le infosProspectLayout alors va avoir sa visibilit\u00e9 modifi\u00e9, il va apparaitre ou disparaitre en fonction de si il est ou non pr\u00e9sent, nous parlons ici aussi d'un filtresLayout mais cela fait partie de la recherche de prospect. Nous avions vu auparavant ce code ci-dessous dans la classe ShowProspectAdaptater . holder . row_prospect . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { interfaceClickable . setClick ( position , prospectList ); } }); Il met en place le fait que ce soit sur les lignes du tableau que nous allons cliquer gr\u00e2ce \u00e0 l'interface cliquable. Exemple de clic sur un prospect (le Siren n'est pas correct, le prospect avait \u00e9t\u00e9 fait avant les r\u00e8gles sur l'ajout d'un prospect) :","title":"D\u00e9tails"},{"location":"javaAndroid/menuActivity/#recherche-de-prospect","text":"Hormis la partie infosProspectLayout cach\u00e9e, une autre l'est aussi, c'est filtresLayout , elle ressemble \u00e0 \u00e7a : Elle va permettre de faire une recherche qui va actualiser la liste des prospects et dont affich\u00e9 que ce que l'utilisateur veut. La premi\u00e8re m\u00e9thode est un \u00e9v\u00e9nement de bouton, le bouton de la page d'accueil \"Rechercher\" le provoque. public View . OnClickListener eventBtnRechercherVisibility = new View . OnClickListener () { boolean visible ; @Override public void onClick ( View v ) { infosProspectLayout . setVisibility ( View . GONE ); TransitionManager . beginDelayedTransition ( filtresLayout ); visible = ! visible ; filtresLayout . setVisibility ( visible ? View . VISIBLE : View . GONE ); } }; Il permet de changer la visibilit\u00e9 du filtresLayout en visible ou non si l'on reclick dessus. Ensuite il est possible d'\u00e9crire trois crit\u00e8re, le nom, le pr\u00e9nom et la raison sociale. On peut \u00e9crire quelque chose dans un seul ou m\u00eame dans les trois et d\u00e8s que l'on va appuyer sur le bouton Lancer la Recherche la m\u00e9thode suivant va se lancer : public View . OnClickListener eventBtnRechercher = new View . OnClickListener () { @Override public void onClick ( View v ) { ArrayList < Prospect > lesProspects = dataBase . getProspectBdd (). getProspects ( nomFiltre . getText (). toString (), prenomFiltre . getText (). toString (), entrepriseFiltre . getText (). toString (), true ); setRecyclerView ( lesProspects ); } }; Elle r\u00e9cup\u00e8re une liste de prospect lesProspects qui est le r\u00e9sultat d'un appel d'une m\u00e9thode de la classe ProspectBDD . /** * R\u00e9cup\u00e8re un tableau de prospects * * @param nom String ou null : le nom du prospect * @param prenom String ou null : le prenom du prospect * @param raisonSocial String ou null : la raison social de l'entreprise * @param isUpdate boolean : true si on veux tous les prospects correspondant aux autres crit\u00e8res ou false si on souhaite que les prospects non synchroniser avec le serveur * @return ArrayLsit<Prospect> ou null : la liste des prorpects correspondant aux crit\u00e8res ou null s'il n'existe aucun prospect correspondant */ public ArrayList < Prospect > getProspects ( String nom , String prenom , String raisonSocial , boolean isUpdate ) { open (); String [] params = new String [ ( nom != null ? 1 : 0 ) + ( prenom != null ? 1 : 0 ) + ( raisonSocial != null ? 1 : 0 ) ] ; int paramIndex = 0 ; String where = \"\" ; if ( nom != null ) { where = NOM_COL + \" LIKE ?\" ; params [ paramIndex ++] = nom + \"%\" ; } if ( prenom != null ) { if ( ! where . equals ( \"\" )) where = where + \" AND \" ; where = where + PRENOM_COL + \" LIKE ?\" ; params [ paramIndex ++] = prenom + \"%\" ; } if ( raisonSocial != null ) { if ( ! where . equals ( \"\" )) where = where + \" AND \" ; where = where + RAISON_SOCIAL_COL + \" LIKE ?\" ; params [ paramIndex ++] = raisonSocial + \"%\" ; } if ( ! isUpdate ) { if ( ! where . equals ( \"\" )) where = where + \" AND \" ; where = where + IS_UPDATE_COL + \" = 0\" ; } Cursor c = getBdd (). query ( getTableName (), new String [] { NOM_COL , PRENOM_COL , TEL_COL , MAIL_COL , NOTES_COL , SIRET_COL , RAISON_SOCIAL_COL , IS_UPDATE_COL }, where , params , null , null , null ); if ( c == null || c . getCount () == 0 ) { return null ; } c . moveToFirst (); Prospect leProspect = cursorToProspect ( c ); ArrayList < Prospect > lesProspects = new ArrayList <> (); lesProspects . add ( leProspect ); if ( c . getCount () > 1 ) { for ( int i = 1 ; i < c . getCount (); i ++ ) { c . moveToNext (); lesProspects . add ( cursorToProspect ( c )); } } c . close (); close (); return lesProspects ; } La m\u00e9thode va nous permettre de faire des recherches SQL par rapport aux entr\u00e9es de l'utilisateur. Nous nous retrouvons finalement avec le tableau affichant les prospects avec les nouveaux correspondant aux recherches. Malgr\u00e9 tout si nous voulosn annuler les filtres alors il suffit d'appuyer sur le bouton Effacer les crit\u00e8res . public void eventBtnClearFiltres ( View v ) { nomFiltre . setText ( \"\" ); prenomFiltre . setText ( \"\" ); entrepriseFiltre . setText ( \"\" ); ArrayList < Prospect > lesProspects = dataBase . getProspectBdd (). getProspects ( null , null , null , true ); setRecyclerView ( lesProspects ); } Il remet le contenu des EditText vide et r\u00e9tabli la liste lesProspects avec les informations de base.","title":"Recherche de prospect"},{"location":"javaAndroid/menuActivity/#synchronisation-avec-le-serveur-externe","text":"Ce diagramme de s\u00e9quence repr\u00e9sente la r\u00e9cup\u00e9ration des prospects depuis l'api au format json et de l'ajout en base de donn\u00e9es local. Et dans un second temps la r\u00e9cup\u00e9ration des prospects en base de donn\u00e9es SQLite puis du formatage en json pour l'envoi au serveur. sequenceDiagram actor Commercial Commercial ->>+ Activity Menu: bouton synchroniser Activity Menu ->>+ APIBdd: callWebService(getAllProspects) APIBdd -->>- Activity Menu: JSONArray json loop updateBddProspects(json) Activity Menu -)+ Prospect: create with json data Prospect -->>- Activity Menu: object Activity Menu ->>+ DAO: add Prospect DAO -->>- Activity Menu: resultat insertion end Activity Menu ->>+ DAO: getProspect DAO -->>- Activity Menu: ArrayList<Prospect> Activity Menu ->>+ APIBdd: createJsonProspects(lesProspects) APIBdd -->>- Activity Menu: JSONArray jsonProspects Activity Menu ->> APIBdd: postJsonProspect(\"InsertProspect\", jsonProspects) Activity Menu -->>- Commercial: boiteMessage(resultApi) L'\u00e9v\u00e8nement du bouton est d\u00e9clar\u00e9 dans eventBtnSynchroniser . La date de mise \u00e0 jour permet de r\u00e9cup\u00e9rer les prospects cr\u00e9er \u00e0 une date ult\u00e9rieure \u00e0 celle de la mise \u00e0 jour et donc limiter le nombres d'informations transmis en bande passante. Pour le POST : application envoie seulement les prospects pour lesquelles la valeur isupdate de la colonne est \u00e0 false, il s'agit d'une valeur boolean pour savoir s'il le prospect est d\u00e9j\u00e0 synchronis\u00e9 avec le serveur externe. public View . OnClickListener eventBtnSynchroniser = new View . OnClickListener () { @Override public void onClick ( View v ) { loading . startLoadingDialog (); SimpleDateFormat formatter = new SimpleDateFormat ( \"yyyy-MM-dd HH:mm:ss\" ); formatter . setTimeZone ( TimeZone . getTimeZone ( \"UTC\" )); Date date = new Date (); String dateMiseAjour = formatter . format ( date ); ApiBdd api = new ApiBdd (); api . callWebService ( \"getAllProspects.php?date=\" + lEmployee . getDateMiseAjour (). replace ( \":\" , \"!\" )); JSONArray json = api . getJsonData (); updateBddProspects ( json ); ArrayList < Prospect > lesProspects = dataBase . getProspectBdd (). getProspects ( null , null , null , false ); //getAllProspects(); if ( lesProspects != null ){ JSONArray jsonProspects = api . createJsonProspects ( lesProspects ); api . postJsonProspect ( \"insertProspect.php?date=\" + lEmployee . getDateMiseAjour (). replace ( \":\" , \"!\" ), jsonProspects . toString ()); } lEmployee . setDateMiseAjour ( dateMiseAjour ); dataBase . getEmployeeBdd (). update ( lEmployee ); loading . dismissDialog (); boiteMessage ( api . getResult ()); setRecyclerView ( dataBase . getProspectBdd (). getProspects ( null , null , null , true )); } }; Pour obtenir le bon format des donn\u00e9es en json et mettre \u00e0 jour le fichier SQLite la m\u00e9thode updateBddProspects d\u00e9compose l'objet et insert en bdd les prospects. Pour cr\u00e9er le format de donn\u00e9es \u00e0 envoyer on utilise la m\u00e9thode createJsonProspects(ArrayList<Prospect> lesProspects) . /** * Formate une liste de prospect en json * * @param lesProspects ArrayList : la liste de prospects * @return JsonArray : les prospects au format json */ public JSONArray createJsonProspects ( ArrayList < Prospect > lesProspects ) { //Creating a JSONObject object JSONArray jsonArray = new JSONArray (); try { for ( Prospect prospect : lesProspects ) { JSONObject jsonObject = new JSONObject (); //Inserting key-value pairs into the json object jsonObject . put ( \"id\" , \"default\" ); jsonObject . put ( \"nom\" , prospect . getNom ()); jsonObject . put ( \"prenom\" , prospect . getPrenom ()); jsonObject . put ( \"mail\" , prospect . getMail ()); jsonObject . put ( \"tel\" , prospect . getTel ()); jsonObject . put ( \"note\" , prospect . getNotes ()); jsonObject . put ( \"siret\" , prospect . getSiret ()); jsonObject . put ( \"raisonsocial\" , prospect . getRaisonSocial ()); jsonArray . put ( jsonObject ); } } catch ( Exception e ) { e . printStackTrace (); } return jsonArray ; } Le bouton Ajouter change l'activit\u00e9 vers AjoutProspectActivity","title":"Synchronisation avec le serveur externe"}]}